{"remainingRequest":"C:\\Users\\jpatrick\\Documents\\GitHub\\DuetWebControl_Fork\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\Users\\jpatrick\\Documents\\GitHub\\DuetWebControl_Fork\\src\\components\\charts\\TemperatureChart.vue?vue&type=style&index=0&id=3e74f109&scoped=true&lang=css&","dependencies":[{"path":"C:\\Users\\jpatrick\\Documents\\GitHub\\DuetWebControl_Fork\\src\\components\\charts\\TemperatureChart.vue","mtime":1592248188514},{"path":"C:\\Users\\jpatrick\\Documents\\GitHub\\DuetWebControl_Fork\\node_modules\\css-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\jpatrick\\Documents\\GitHub\\DuetWebControl_Fork\\node_modules\\vue-loader\\lib\\loaders\\stylePostLoader.js","mtime":499162500000},{"path":"C:\\Users\\jpatrick\\Documents\\GitHub\\DuetWebControl_Fork\\node_modules\\postcss-loader\\src\\index.js","mtime":499162500000},{"path":"C:\\Users\\jpatrick\\Documents\\GitHub\\DuetWebControl_Fork\\node_modules\\vuetify-loader\\lib\\loader.js","mtime":1574476662000},{"path":"C:\\Users\\jpatrick\\Documents\\GitHub\\DuetWebControl_Fork\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\jpatrick\\Documents\\GitHub\\DuetWebControl_Fork\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:DQouY2FyZCB7DQoJZGlzcGxheTogZmxleDsNCglmbGV4LWRpcmVjdGlvbjogY29sdW1uOw0KCXdpZHRoOiAxMDAlOw0KfQ0KDQouY29udGVudCB7DQoJcG9zaXRpb246IHJlbGF0aXZlOw0KfQ0KDQouY29udGVudCA+IGNhbnZhcyB7DQoJcG9zaXRpb246IGFic29sdXRlOw0KfQ0K"},{"version":3,"sources":["TemperatureChart.vue"],"names":[],"mappings":";AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA","file":"TemperatureChart.vue","sourceRoot":"src/components/charts","sourcesContent":["<style scoped>\r\n.card {\r\n\tdisplay: flex;\r\n\tflex-direction: column;\r\n\twidth: 100%;\r\n}\r\n\r\n.content {\r\n\tposition: relative;\r\n}\r\n\r\n.content > canvas {\r\n\tposition: absolute;\r\n}\r\n</style>\r\n\r\n<template>\r\n\t<v-card class=\"d-flex flex-column flex-grow-1\">\r\n\t\t<v-card-title class=\"pt-2 pb-0\">\r\n\t\t\t<v-icon class=\"mr-1\">mdi-chart-timeline-variant</v-icon> {{ $t('chart.temperature.caption') }}\r\n\t\t</v-card-title>\r\n\r\n\t\t<v-card-text v-show=\"hasTemperaturesToDisplay\" class=\"content flex-grow-1 px-2 py-0\">\r\n\t\t\t<canvas ref=\"chart\"></canvas>\r\n\t\t</v-card-text>\r\n\r\n\t\t<v-spacer v-show=\"!hasTemperaturesToDisplay\"></v-spacer>\r\n\t\t<v-card-text class=\"pa-0\" v-show=\"!hasTemperaturesToDisplay\">\r\n\t\t\t<v-alert :value=\"true\" type=\"info\" class=\"mb-0\">\r\n\t\t\t\t{{ $t('chart.temperature.noData') }}\r\n\t\t\t</v-alert>\r\n\t\t</v-card-text>\r\n\t</v-card>\r\n</template>\r\n\r\n<script>\r\n'use strict'\r\n\r\nimport Chart from 'chart.js'\r\nimport { mapState, mapGetters } from 'vuex'\r\n\r\nimport i18n from '../../i18n'\r\nimport { defaultMachine } from '../../store/machine'\r\nimport { getRealHeaterColor } from '../../utils/colors.js'\r\n\r\nconst sampleInterval = 1000\t\t\t// ms\r\nconst defaultMaxTemperature = 300\t// degC\r\nconst maxSampleTime = 600000\t\t// 10min (in ms)\r\n\r\nfunction makeDataset(index, extra, label, numSamples) {\r\n\tconst color = getRealHeaterColor(index, extra), dataset = {\r\n\t\tindex,\r\n\t\textra,\r\n\t\tlabel,\r\n\t\tfill: false,\r\n\t\tbackgroundColor: color,\r\n\t\tborderColor: color,\r\n\t\tborderDash: extra ? [10, 5] : undefined,\r\n\t\tborderWidth: 2,\r\n\t\tdata: [],\r\n\t\tlocale: i18n.locale,\r\n\t\tpointRadius: 0,\r\n\t\tpointHitRadius: 0,\r\n\t\tshowLine: true\r\n\t};\r\n\tdataset.data = (new Array(numSamples)).fill(NaN);\r\n\treturn dataset;\r\n}\r\n\r\nconst tempSamples = {\r\n\t[defaultMachine]: {\r\n\t\ttimes: [],\r\n\t\ttemps: []\r\n\t}\r\n}\r\n\r\nfunction pushSeriesData(machine, index, extra, sensor) {\r\n\t// Get series from dataset\r\n\tconst machineData = tempSamples[machine];\r\n\tlet dataset = machineData.temps.find(function(item) {\r\n\t\tif (item.index === index && item.extra === extra) {\r\n\t\t\treturn item;\r\n\t\t}\r\n\t});\r\n\r\n\t// Check if the dataset has to be created first\r\n\tif (!dataset || dataset.locale !== i18n.locale || dataset.rawLabel !== sensor.name) {\r\n\t\tlet name;\r\n\t\tif (sensor.name) {\r\n\t\t\tconst matches = /(.*)\\[(.*)\\]$/.exec(sensor.name);\r\n\t\t\tname = matches ? matches[1] : sensor.name;\r\n\t\t} else {\r\n\t\t\tname = i18n.t('chart.temperature.heater', [index]);\r\n\t\t}\r\n\r\n\t\tif (dataset) {\r\n\t\t\tdataset.rawLabel = sensor.name;\r\n\t\t\tdataset.label = name;\r\n\t\t\tdataset.locale = i18n.locale;\r\n\t\t} else {\r\n\t\t\tdataset = makeDataset(index, extra, name, tempSamples[machine].times.length);\r\n\t\t\tmachineData.temps.push(dataset);\r\n\t\t}\r\n\t}\r\n\r\n\t// Add new sample\r\n\tdataset.data.push(sensor.lastReading);\r\n}\r\n\r\nlet storeSubscribed = false, instances = []\r\n\r\nexport default {\r\n\tcomputed: {\r\n\t\t...mapState(['selectedMachine']),\r\n\t\t...mapGetters(['isConnected']),\r\n\t\t...mapGetters('machine', ['hasTemperaturesToDisplay']),\r\n\t\t...mapGetters('machine/model', ['maxHeaterTemperature']),\r\n\t\t...mapState('machine/model', ['heat']),\r\n\t\t...mapState('machine/settings', ['displayedExtraTemperatures']),\r\n\t\t...mapState('settings', ['darkTheme'])\r\n\t},\r\n\tdata() {\r\n\t\treturn {\r\n\t\t\tchart: null,\r\n\t\t\tpauseUpdate: false\r\n\t\t}\r\n\t},\r\n\tmethods: {\r\n\t\tupdate() {\r\n\t\t\tthis.chart.config.options.scales.yAxes[0].ticks.max = this.maxHeaterTemperature || defaultMaxTemperature;\r\n\t\t\tthis.chart.config.options.scales.xAxes[0].ticks.min = new Date() - maxSampleTime;\r\n\t\t\tthis.chart.config.options.scales.xAxes[0].ticks.max = new Date();\r\n\t\t\tthis.chart.update();\r\n\t\t},\r\n\t\tapplyDarkTheme(active) {\r\n\t\t\tconst legendColor = active ? '#FFF' : 'rgba(0,0,0,0.87)';\r\n\t\t\tthis.chart.config.options.legend.labels.fontColor = legendColor;\r\n\r\n\t\t\tconst ticksColor = active ? '#FFF' : '#666';\r\n\t\t\tthis.chart.config.options.scales.xAxes[0].ticks.major.fontColor = ticksColor;\r\n\t\t\tthis.chart.config.options.scales.xAxes[0].ticks.minor.fontColor = ticksColor;\r\n\t\t\tthis.chart.config.options.scales.yAxes[0].ticks.major.fontColor = ticksColor;\r\n\t\t\tthis.chart.config.options.scales.yAxes[0].ticks.minor.fontColor = ticksColor;\r\n\r\n\t\t\tconst gridLineColor = active ? 'rgba(255,255,255,0.15)' : 'rgba(0,0,0,0.15)';\r\n\t\t\tthis.chart.config.options.scales.xAxes[0].gridLines.color = gridLineColor;\r\n\t\t\tthis.chart.config.options.scales.yAxes[0].gridLines.color = gridLineColor;\r\n\t\t\tthis.chart.config.options.scales.yAxes[0].gridLines.zeroLineColor = gridLineColor;\r\n\r\n\t\t\tthis.chart.update();\r\n\t\t}\r\n\t},\r\n\tmounted() {\r\n\t\t// Create new chart options. Don't use data for the following because it should not be reactive\r\n\t\tthis.options = {\r\n\t\t\tanimation: {\r\n\t\t\t\tduration: 0\t\t\t\t\t// general animation time\r\n\t\t\t},\r\n\t\t\telements: {\r\n\t\t\t\tline: {\r\n\t\t\t\t\ttension: 0\t\t\t\t// disable bezier curves\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tlegend: {\r\n\t\t\t\tlabels: {\r\n\t\t\t\t\tfilter: (legendItem, data) => data.datasets[legendItem.datasetIndex].showLine,\r\n\t\t\t\t\tfontFamily: 'Roboto,sans-serif'\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tmaintainAspectRatio: false,\r\n\t\t\tresponsive: true,\r\n\t\t\tresponsiveAnimationDuration: 0, // animation duration after a resize\r\n\t\t\tscales: {\r\n\t\t\t\txAxes: [\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tgridLines: {\r\n\t\t\t\t\t\t\tcolor: 'rgba(0,0,0,0.2)',\r\n\t\t\t\t\t\t\tdisplay: true\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tticks: {\r\n\t\t\t\t\t\t\tmin: new Date() - maxSampleTime,\r\n\t\t\t\t\t\t\tmax: new Date(),\r\n\t\t\t\t\t\t\tminor: {\r\n\t\t\t\t\t\t\t\tfontColor: 'rgba(0,0,0,0.87)',\r\n\t\t\t\t\t\t\t\tfontFamily: 'Roboto,sans-serif'\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tmajor: {\r\n\t\t\t\t\t\t\t\tfontColor: 'rgba(0,0,0,0.87)',\r\n\t\t\t\t\t\t\t\tfontFamily: 'Roboto,sans-serif'\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\ttime: {\r\n\t\t\t\t\t\t\tunit: 'minute',\r\n\t\t\t\t\t\t\tdisplayFormats: {\r\n\t\t\t\t\t\t\t\tminute: 'HH:mm'\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\ttype: 'time',\r\n\t\t\t\t\t}\r\n\t\t\t\t],\r\n\t\t\t\tyAxes: [\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tgridLines: {\r\n\t\t\t\t\t\t\tcolor: 'rgba(0,0,0,0.2)',\r\n\t\t\t\t\t\t\tzeroLineColor: 'rgba(0,0,0,0.2)',\r\n\t\t\t\t\t\t\tdisplay: true\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tticks: {\r\n\t\t\t\t\t\t\tminor: {\r\n\t\t\t\t\t\t\t\tfontColor: '#666',\r\n\t\t\t\t\t\t\t\tfontFamily: 'Roboto,sans-serif'\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tmajor: {\r\n\t\t\t\t\t\t\t\tfontColor: '#666',\r\n\t\t\t\t\t\t\t\tfontFamily: 'Roboto,sans-serif'\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tmin: 0,\r\n\t\t\t\t\t\t\tmax: defaultMaxTemperature,\r\n\t\t\t\t\t\t\tstepSize: 50\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t]\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// Create the dataset if necessary\r\n\t\tif (tempSamples[this.selectedMachine] === undefined) {\r\n\t\t\ttempSamples[this.selectedMachine] = {\r\n\t\t\t\ttimes: [],\r\n\t\t\t\ttemps: []\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// Create the chart\r\n\t\tthis.chart = Chart.Line(this.$refs.chart, {\r\n\t\t\toptions: this.options,\r\n\t\t\tdata: {\r\n\t\t\t\tlabels: tempSamples[this.selectedMachine].times,\r\n\t\t\t\tdatasets: tempSamples[this.selectedMachine].temps\r\n\t\t\t}\r\n\t\t});\r\n\t\tthis.applyDarkTheme(this.darkTheme);\r\n\r\n\t\t// Keep track of updates\r\n\t\tinstances.push(this);\r\n\t\tif (!storeSubscribed) {\r\n\t\t\tthis.$store.subscribe((mutation, state) => {\r\n\t\t\t\tif (mutation.type === 'addMachine') {\r\n\t\t\t\t\t// Machine has been added\r\n\t\t\t\t\ttempSamples[mutation.payload.hostname] = {\r\n\t\t\t\t\t\ttimes: [],\r\n\t\t\t\t\t\ttemps: []\r\n\t\t\t\t\t};\r\n\t\t\t\t} else if (mutation.type === 'removeMachine') {\r\n\t\t\t\t\t// Machine has been removed\r\n\t\t\t\t\tdelete tempSamples[mutation.payload];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconst result = /machines\\/(.+)\\/model\\/update/.exec(mutation.type);\r\n\t\t\t\t\tif (result) {\r\n\t\t\t\t\t\t// New data received\r\n\t\t\t\t\t\tconst machine = result[1], dataset = tempSamples[machine], now = new Date();\r\n\t\t\t\t\t\tif (dataset.times.length === 0 || now - dataset.times[dataset.times.length - 1] > sampleInterval) {\r\n\t\t\t\t\t\t\t// Record sensor temperatures\r\n\t\t\t\t\t\t\tstate.machines[machine].model.sensors.analog.forEach(function(sensor, sensorIndex) {\r\n\t\t\t\t\t\t\t\tif (sensor) {\r\n\t\t\t\t\t\t\t\t\tconst heaterIndex = state.machines[machine].model.heat.heaters.findIndex(heater => heater && heater.sensor === sensorIndex);\r\n\t\t\t\t\t\t\t\t\tif (heaterIndex !== -1) {\r\n\t\t\t\t\t\t\t\t\t\tpushSeriesData(machine, heaterIndex, false, sensor);\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tpushSeriesData(machine, sensorIndex, true, sensor);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t// Record time and deal wih expired temperature samples\r\n\t\t\t\t\t\t\twhile (dataset.times.length && now - dataset.times[0] > maxSampleTime) {\r\n\t\t\t\t\t\t\t\tdataset.times.shift();\r\n\t\t\t\t\t\t\t\tdataset.temps.forEach(data => data.data.shift());\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tdataset.times.push(now);\r\n\r\n\t\t\t\t\t\t\t// Deal with visibility and tell chart instances to update\r\n\t\t\t\t\t\t\tdataset.temps.forEach(function(dataset) {\r\n\t\t\t\t\t\t\t\tdataset.showLine = !dataset.extra || (this.displayedExtraTemperatures.indexOf(dataset.index) !== -1);\r\n\t\t\t\t\t\t\t}, this);\r\n\t\t\t\t\t\t\tinstances.forEach(instance => instance.update());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tstoreSubscribed = true;\r\n\t\t}\r\n\t},\r\n\tbeforeDestroy() {\r\n\t\t// Don't update this instance any more...\r\n\t\tinstances = instances.filter(instance => instance !== this, this);\r\n\t},\r\n\twatch: {\r\n\t\tdarkTheme(to) {\r\n\t\t\tthis.applyDarkTheme(to);\r\n\t\t},\r\n\t\tselectedMachine(machine) {\r\n\t\t\t// Each chart instance is fixed to the currently selected machine\r\n\t\t\t// Reassign the corresponding dataset whenever the selected machine changes\r\n\t\t\tthis.chart.config.data = {\r\n\t\t\t\tlabels: tempSamples[machine].times,\r\n\t\t\t\tdatasets: tempSamples[machine].temps\r\n\t\t\t};\r\n\t\t\tthis.update();\r\n\t\t}\r\n\t}\r\n}\r\n</script>\r\n"]}]}